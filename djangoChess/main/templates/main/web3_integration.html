<!-- Web3 Integration Script for Chess dApp - Production Ready -->
<script src="https://cdn.jsdelivr.net/npm/web3@1.10.0/dist/web3.min.js"></script>
<script>
// Chess dApp Web3 Integration
const ChessWeb3 = {
    web3: null,
    contract: null,
    contractAddress: '{{ CHESS_CONTRACT_ADDRESS }}',
    rpcUrl: '{{ BLOCKCHAIN_RPC_URL }}',
    networkName: '{{ BLOCKCHAIN_NETWORK }}',
    chainId: {{ CHAIN_ID }},
    gameId: {{ game.id }},
    betAmount: '{{ game.bet_amount }}',
    userAddress: '{{ user_ethereum_address }}',
    
    // Network configurations
    networks: {
        anvil: {
            chainId: '0x7a69',  // 31337
            chainIdDecimal: 31337,
            name: 'Anvil Local',
            rpcUrl: 'http://127.0.0.1:8545',
            nativeCurrency: { name: 'Ethereum', symbol: 'ETH', decimals: 18 },
            blockExplorer: null
        },
        'base-sepolia': {
            chainId: '0x14a34',  // 84532
            chainIdDecimal: 84532,
            name: 'Base Sepolia Testnet',
            rpcUrl: 'https://sepolia.base.org',
            nativeCurrency: { name: 'Ethereum', symbol: 'ETH', decimals: 18 },
            blockExplorer: 'https://sepolia.basescan.org'
        },
        base: {
            chainId: '0x2105',  // 8453
            chainIdDecimal: 8453,
            name: 'Base',
            rpcUrl: 'https://mainnet.base.org',
            nativeCurrency: { name: 'Ethereum', symbol: 'ETH', decimals: 18 },
            blockExplorer: 'https://basescan.org'
        }
    },
    
    // Initialize Web3 connection
    async init() {
        console.log('=== INITIALIZING CHESS WEB3 ===');
        console.log('Network:', this.networkName);
        console.log('Contract:', this.contractAddress);
        console.log('Game ID:', this.gameId);
        
        const networkConfig = this.networks[this.networkName];
        
        if (!networkConfig) {
            this.updateStatus('‚ùå Unknown network: ' + this.networkName, 'error');
            return false;
        }
        
        try {
            // Check if MetaMask is available
            if (typeof window.ethereum !== 'undefined') {
                this.web3 = new Web3(window.ethereum);
                
                // Request account access
                try {
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    console.log('‚úÖ MetaMask connected');
                } catch (error) {
                    console.log('User denied MetaMask access');
                }
                
                // Check if user is on correct network
                const currentChainId = await window.ethereum.request({ method: 'eth_chainId' });
                console.log('Current chain:', currentChainId, 'Expected:', networkConfig.chainId);
                
                if (currentChainId !== networkConfig.chainId) {
                    await this.switchNetwork(networkConfig);
                }
                
                // Listen for network changes
                window.ethereum.on('chainChanged', () => window.location.reload());
                window.ethereum.on('accountsChanged', () => window.location.reload());
                
            } else if (this.networkName === 'anvil') {
                // For Anvil, use direct HTTP connection
                this.web3 = new Web3(new Web3.providers.HttpProvider(this.rpcUrl));
                console.log('‚úÖ Connected to Anvil via HTTP');
            } else {
                this.updateStatus('‚ùå MetaMask not detected. Please install MetaMask.', 'error');
                return false;
            }
            
            // Load contract
            await this.loadContract();
            
            this.updateStatus('‚úÖ Connected to ' + networkConfig.name, 'success');
            return true;
            
        } catch (error) {
            console.error('Init error:', error);
            this.updateStatus('‚ùå Connection failed: ' + error.message, 'error');
            return false;
        }
    },
    
    // Switch to correct network
    async switchNetwork(networkConfig) {
        if (this.networkName === 'anvil') {
            alert('Please use Anvil locally via HTTP (no MetaMask needed for local testing)');
            return;
        }
        
        try {
            // Try to switch to the network
            await window.ethereum.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: networkConfig.chainId }],
            });
            
            console.log('‚úÖ Switched to', networkConfig.name);
            
        } catch (error) {
            // If network not added, add it
            if (error.code === 4902) {
                try {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                            chainId: networkConfig.chainId,
                            chainName: networkConfig.name,
                            nativeCurrency: networkConfig.nativeCurrency,
                            rpcUrls: [networkConfig.rpcUrl],
                            blockExplorerUrls: networkConfig.blockExplorer ? [networkConfig.blockExplorer] : []
                        }]
                    });
                    
                    console.log('‚úÖ Added', networkConfig.name, 'to MetaMask');
                    
                } catch (addError) {
                    console.error('Failed to add network:', addError);
                    throw addError;
                }
            } else {
                throw error;
            }
        }
    },
    
    // Load contract ABI and create instance
    async loadContract() {
        try {
            const response = await fetch('/chess/api/contract-abi/');
            const data = await response.json();
            
            if (!data.success) {
                throw new Error('Could not load contract ABI');
            }
            
            this.contract = new this.web3.eth.Contract(data.abi, this.contractAddress);
            console.log('‚úÖ Contract loaded');
            
        } catch (error) {
            console.error('Error loading contract:', error);
            throw error;
        }
    },
    
    // Get user's current address
    async getUserAddress() {
        if (this.networkName === 'anvil') {
            const accounts = await this.web3.eth.getAccounts();
            return this.userAddress || accounts[0];
        } else {
            const accounts = await window.ethereum.request({ method: 'eth_accounts' });
            return accounts[0];
        }
    },
    
    // Deposit ETH to contract
    async deposit() {
        if (parseFloat(this.betAmount) === 0) {
            alert('This is a free game, no deposit needed!');
            return;
        }
        
        this.updateStatus('üîÑ Preparing deposit...', 'info');
        
        try {
            const betWei = this.web3.utils.toWei(this.betAmount, 'ether');
            const userAccount = await this.getUserAddress();
            
            // Check balance
            const balance = await this.web3.eth.getBalance(userAccount);
            if (BigInt(balance) < BigInt(betWei)) {
                this.updateStatus('‚ùå Insufficient balance', 'error');
                alert(`You need ${this.betAmount} ETH but have ${this.web3.utils.fromWei(balance, 'ether')} ETH`);
                return;
            }
            
            this.updateStatus('üîÑ Sending deposit transaction...', 'info');
            
            // Send transaction
            const tx = await this.contract.methods.deposit(this.gameId).send({
                from: userAccount,
                value: betWei,
                gas: 300000
            });
            
            console.log('‚úÖ Deposit successful:', tx.transactionHash);
            this.updateStatus('‚úÖ Deposit confirmed!', 'success');
            
            // Show block explorer link if available
            const networkConfig = this.networks[this.networkName];
            if (networkConfig.blockExplorer) {
                const link = `${networkConfig.blockExplorer}/tx/${tx.transactionHash}`;
                this.updateStatus(`‚úÖ Deposit confirmed! View: ${link}`, 'success');
            }
            
            await this.saveDepositTx(tx.transactionHash);
            await this.checkDepositStatus();
            
        } catch (error) {
            console.error('Deposit error:', error);
            this.updateStatus('‚ùå Deposit failed: ' + error.message, 'error');
        }
    },
    
    // Check deposit status
    async checkDepositStatus() {
        this.updateStatus('üîÑ Checking deposit status...', 'info');
        
        try {
            const challenge = await this.contract.methods.get_challenge(this.gameId).call();
            
            const hasWhiteDeposit = challenge.player_white !== '0x0000000000000000000000000000000000000000';
            const hasBlackDeposit = challenge.player_black !== '0x0000000000000000000000000000000000000000';
            const isActive = challenge.is_active;
            
            let status = 'üìä Deposit Status:\n';
            status += `White: ${hasWhiteDeposit ? '‚úÖ' : '‚è≥'} `;
            status += `Black: ${hasBlackDeposit ? '‚úÖ' : '‚è≥'} `;
            status += `Game: ${isActive ? '‚úÖ Active' : '‚è≥ Waiting'}`;
            
            this.updateStatus(status, isActive ? 'success' : 'info');
            
        } catch (error) {
            console.error('Status check error:', error);
        }
    },
    
    // Claim winnings
    async claimWinnings() {
        this.updateStatus('üîÑ Fetching signature...', 'info');
        
        try {
            const response = await fetch(`/chess/api/get-signature/{{ game.id }}/`, {
                credentials: 'same-origin'
            });
            
            const data = await response.json();
            
            if (!data.success) {
                this.updateStatus('‚ùå ' + data.message, 'error');
                alert(data.message);
                return;
            }
            
            if (data.is_draw) {
                alert('Game was a draw. Use "Claim Refund" instead.');
                return;
            }
            
            const { signature, winner_address } = data;
            const userAccount = await this.getUserAddress();
            
            this.updateStatus('üîÑ Claiming winnings...', 'info');
            
            const tx = await this.contract.methods.claim_winnings(
                this.gameId,
                this.web3.utils.toChecksumAddress(winner_address),
                signature.v,
                signature.r,
                signature.s
            ).send({
                from: userAccount,
                gas: 300000
            });
            
            console.log('‚úÖ Claim successful:', tx.transactionHash);
            this.updateStatus('‚úÖ Winnings claimed!', 'success');
            
            const networkConfig = this.networks[this.networkName];
            if (networkConfig.blockExplorer) {
                const link = `${networkConfig.blockExplorer}/tx/${tx.transactionHash}`;
                alert(`üéâ Winnings claimed! View transaction: ${link}`);
            } else {
                alert(`üéâ You claimed ${parseFloat(this.betAmount) * 2} ETH!`);
            }
            
            await this.saveClaimTx(tx.transactionHash);
            
        } catch (error) {
            console.error('Claim error:', error);
            this.updateStatus('‚ùå Claim failed: ' + error.message, 'error');
        }
    },
    
    // Claim refund (draw)
    async claimRefund() {
        this.updateStatus('üîÑ Fetching draw signature...', 'info');
        
        try {
            const response = await fetch(`/chess/api/get-signature/{{ game.id }}/`, {
                credentials: 'same-origin'
            });
            
            const data = await response.json();
            
            if (!data.success) {
                this.updateStatus('‚ùå ' + data.message, 'error');
                alert(data.message);
                return;
            }
            
            if (!data.is_draw) {
                alert('This game was not a draw.');
                return;
            }
            
            const { signature } = data;
            const userAccount = await this.getUserAddress();
            
            this.updateStatus('üîÑ Claiming refund (both players will be refunded)...', 'info');
            
            const tx = await this.contract.methods.settle_draw(
                this.gameId,
                signature.v,
                signature.r,
                signature.s
            ).send({
                from: userAccount,
                gas: 300000
            });
            
            console.log('‚úÖ Refund successful:', tx.transactionHash);
            this.updateStatus('‚úÖ Draw settled - both players refunded!', 'success');
            
            const networkConfig = this.networks[this.networkName];
            if (networkConfig.blockExplorer) {
                const link = `${networkConfig.blockExplorer}/tx/${tx.transactionHash}`;
                alert(`üí∞ Draw settled! Both players refunded. View: ${link}`);
            } else {
                alert(`üí∞ Draw settled! You received ${this.betAmount} ETH`);
            }
            
            await this.saveClaimTx(tx.transactionHash);
            
        } catch (error) {
            console.error('Refund error:', error);
            this.updateStatus('‚ùå Refund failed: ' + error.message, 'error');
        }
    },
    
    // Save deposit transaction
    async saveDepositTx(txHash) {
        try {
            await fetch(`/chess/api/verify-deposit/{{ game.id }}/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: JSON.stringify({ tx_hash: txHash })
            });
        } catch (error) {
            console.error('Error saving deposit:', error);
        }
    },
    
    // Save claim transaction
    async saveClaimTx(txHash) {
        try {
            await fetch(`/chess/api/mark-payout/{{ game.id }}/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: JSON.stringify({ tx_hash: txHash })
            });
        } catch (error) {
            console.error('Error saving claim:', error);
        }
    },
    
    // Update status display
    updateStatus(message, type = 'info') {
        const statusEl = document.getElementById('blockchain-status');
        if (statusEl) {
            statusEl.textContent = message;
            statusEl.className = 'text-sm font-mono whitespace-pre-line ';
            
            if (type === 'error') {
                statusEl.className += 'text-red-400';
            } else if (type === 'success') {
                statusEl.className += 'text-green-400';
            } else {
                statusEl.className += 'text-blue-400';
            }
        }
        console.log(`[${type}]`, message);
    }
};

// Initialize on page load
document.addEventListener('DOMContentLoaded', async () => {
    await ChessWeb3.init();
    
    if (parseFloat(ChessWeb3.betAmount) > 0) {
        await ChessWeb3.checkDepositStatus();
    }
});

// Expose to global scope
window.ChessWeb3 = ChessWeb3;
</script>