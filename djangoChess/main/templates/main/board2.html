<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Chess Match #{{ game.id }}</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <style>
        [x-cloak] { display: none !important; }
        .modal-overlay { z-index: 9999 !important; }
        .timer-active { @apply border-blue-500 shadow-[0_0_20px_rgba(59,130,246,0.4)] bg-blue-900/20; }
        #myBoard { @apply rounded-xl overflow-hidden border-4 border-gray-800 shadow-2xl; }
        .piece-417db { max-width: none !important; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen font-sans" x-data="chessGame()" x-init="initBoard()">

    <div class="container mx-auto py-8 px-4">
        
        <!-- Deposit Status Banner (if game has bet) -->
        {% if game.bet_amount > 0 %}
        <div class="mb-6 bg-yellow-900/20 border border-yellow-600 rounded-xl p-4 max-w-[950px] mx-auto">
            <div class="flex items-start gap-3">
                <span class="text-2xl">üí∞</span>
                <div class="flex-1">
                    <h3 class="font-bold text-yellow-400 mb-2">Bet: {{ game.bet_amount }} ETH per player</h3>
                    <div class="text-sm text-gray-300 space-y-1 mb-3">
                        <p>üìç Contract: <span class="font-mono text-xs text-blue-400">{{ CHESS_CONTRACT_ADDRESS|default:"Not configured" }}</span></p>
                        <p>‚ö†Ô∏è Both players must deposit before the game can start</p>
                        <p>üèÜ Winner takes: {{ game.bet_amount|floatformat:3|add:game.bet_amount|floatformat:3 }} ETH</p>
                    </div>
                    
                    <!-- Status Display -->
                    <div class="bg-gray-900/50 rounded p-3 mb-3">
                        <p id="blockchain-status" class="text-sm font-mono text-gray-400">
                            Connecting to blockchain...
                        </p>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div class="flex gap-3 flex-wrap">
                        <button 
                            onclick="ChessWeb3.deposit()" 
                            class="bg-yellow-600 hover:bg-yellow-500 px-4 py-2 rounded-lg text-sm font-bold transition-all"
                        >
                            üí∏ Deposit {{ game.bet_amount }} ETH
                        </button>
                        <button 
                            onclick="ChessWeb3.checkDepositStatus()" 
                            class="bg-blue-600 hover:bg-blue-500 px-4 py-2 rounded-lg text-sm font-bold transition-all"
                        >
                            üîç Check Status
                        </button>
                        {% if not game.is_active and game.winner == request.user %}
                        <button 
                            onclick="ChessWeb3.claimWinnings()" 
                            class="bg-green-600 hover:bg-green-500 px-4 py-2 rounded-lg text-sm font-bold transition-all"
                        >
                            üéâ Claim Winnings
                        </button>
                        {% endif %}
                    </div>
                </div>
            </div>
        </div>
        {% endif %}
        
        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            <div class="lg:col-span-7 flex flex-col items-center">
                <div class="w-full max-w-[450px] mb-4 flex justify-between items-center bg-gray-800 p-4 rounded-xl border border-gray-700 transition-all"
                     :class="activeTurn === (isWhitePlayer ? 'black' : 'white') ? 'timer-active' : ''">
                    <p class="font-bold">Opponent: {% if game.white_player == request.user %}{{ game.black_player.username|default:"Waiting..." }}{% else %}{{ game.white_player.username }}{% endif %}</p>
                    <div class="text-3xl font-mono font-black" x-text="formatTime(isWhitePlayer ? blackTime : whiteTime)">00:00</div>
                </div>

                <div id="myBoard" class="mx-auto" style="width: 100%; max-width: 450px;"></div>

                <div class="w-full max-w-[450px] mt-4 flex justify-between items-center bg-gray-800 p-4 rounded-xl border border-gray-700 transition-all"
                     :class="activeTurn === (isWhitePlayer ? 'white' : 'black') ? 'timer-active' : ''">
                    <p class="font-bold">You ({{ request.user.username }})</p>
                    <div class="text-3xl font-mono font-black" x-text="formatTime(isWhitePlayer ? whiteTime : blackTime)">00:00</div>
                </div>

                <div class="mt-6 flex items-center gap-4 w-full max-w-[450px]">
                    <div class="flex-1 px-4 py-2 bg-gray-800 rounded-lg text-xs font-bold border border-gray-700" x-text="statusMsg">Connecting...</div>
                    <button @click="resign()" class="px-6 py-2 bg-red-600/10 border border-red-600/50 text-red-500 hover:bg-red-600 hover:text-white rounded-lg text-xs font-bold transition-all" :disabled="isGameOver">RESIGN</button>
                </div>
            </div>

            <div class="lg:col-span-5 space-y-6">
                <div class="bg-gray-800 rounded-2xl border border-gray-700 h-48 flex flex-col shadow-xl">
                    <div class="p-4 bg-gray-700/30 border-b border-gray-700 text-xs font-black uppercase text-gray-400">Move History</div>
                    <div class="p-4 overflow-y-auto grid grid-cols-2 gap-x-8 gap-y-1 font-mono text-sm" id="moveList">
                        {% for move in game.moves.all %}
                            <div class="text-gray-500">{{ forloop.counter }}. <span class="text-white font-bold ml-1">{{ move.move_san }}</span></div>
                        {% endfor %}
                    </div>
                </div>

                <div class="bg-gray-800 rounded-2xl border border-gray-700 h-64 flex flex-col shadow-xl">
                    <div class="p-4 bg-gray-700/30 border-b border-gray-700 text-xs font-black uppercase text-gray-400">Chat</div>
                    <div class="flex-1 p-4 overflow-y-auto space-y-2 text-sm" x-ref="chatLog">
                        <template x-for="msg in chatMessages">
                            <div><span class="font-bold text-blue-400" x-text="msg.player + ': '"></span><span x-text="msg.text"></span></div>
                        </template>
                    </div>
                    <div class="p-3 bg-gray-900/50 border-t border-gray-700 flex gap-2">
                        <input x-model="chatInput" @keyup.enter="sendChat()" class="flex-1 bg-gray-800 border border-gray-700 rounded px-3 py-2 text-sm focus:outline-none" placeholder="Message...">
                        <button @click="sendChat()" class="bg-blue-600 px-4 py-2 rounded text-sm font-bold">Send</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div x-show="showPromotion" class="modal-overlay fixed inset-0 bg-black/90 flex items-center justify-center" x-cloak>
        <div class="bg-gray-800 p-8 rounded-3xl text-center border border-gray-700 shadow-2xl">
            <h3 class="text-xl font-bold mb-6">Promote Pawn</h3>
            <div class="flex gap-4">
                <template x-for="p in [{c:'q', s:'‚ôõ'}, {c:'r', s:'‚ôú'}, {c:'b', s:'‚ôù'}, {c:'n', s:'‚ôû'}]">
                    <button @click="selectPromotion(p.c)" class="w-16 h-16 bg-gray-700 hover:bg-blue-600 rounded-xl text-3xl">
                        <span x-text="p.s"></span>
                    </button>
                </template>
            </div>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    
    {% include "main/web3_integration.html" %}
    
    <script>
        function chessGame() {
            return {
                // FIXED: Times now synced from server
                whiteTime: parseFloat("{{ game.white_time }}"),
                blackTime: parseFloat("{{ game.black_time }}"),
                isWhitePlayer: "{{ request.user.username }}" === "{{ game.white_player.username }}",
                activeTurn: "{{ game.current_fen }}".split(" ")[1] === "w" ? "white" : "black",
                isGameOver: "{{ game.is_active }}" === "False",
                statusMsg: "Connecting...",
                showPromotion: false,
                pendingMove: null,
                socket: null,
                board: null,
                chatInput: '',
                chatMessages: [],
                gameStarted: {% if game.last_move_timestamp %}true{% else %}false{% endif %},
                lastUpdateTime: Date.now(), // Track when we last got server update

                initBoard() {
                    this.socket = new WebSocket(`ws://${window.location.host}/ws/chess/{{ game.id }}/`);
                    this.board = Chessboard('myBoard', {
                        draggable: true,
                        position: "{{ game.current_fen }}",
                        orientation: this.isWhitePlayer ? 'white' : 'black',
                        onDrop: (s, t, p) => this.onDrop(s, t, p),
                        pieceTheme: (p) => `https://upload.wikimedia.org/wikipedia/commons/${this.getPieceImg(p)}`
                    });

                    this.socket.onmessage = (e) => this.handleSocketMessage(JSON.parse(e.data));
                    this.socket.onopen = () => this.statusMsg = "Live";
                    
                    // FIXED: Client-side timer only for display smoothness
                    // Server is the source of truth
                    setInterval(() => {
                        if (!this.isGameOver && this.gameStarted) {
                            const now = Date.now();
                            const elapsed = (now - this.lastUpdateTime) / 1000;
                            
                            // Only decrement for display purposes between server updates
                            if (this.activeTurn === 'white' && this.whiteTime > 0) {
                                this.whiteTime = Math.max(0, this.whiteTime - 0.1);
                            } else if (this.activeTurn === 'black' && this.blackTime > 0) {
                                this.blackTime = Math.max(0, this.blackTime - 0.1);
                            }
                        }
                    }, 100); // Update display more frequently for smoothness
                },

                handleSocketMessage(data) {
                    if (data.error) { 
                        alert(data.error); 
                        this.board.position(this.board.fen()); 
                        return; 
                    }
                    
                    if (data.type === 'move') {
                        this.gameStarted = true;
                        this.board.position(data.fen);
                        
                        // CRITICAL FIX: Sync times from server (server is source of truth)
                        this.whiteTime = data.white_time;
                        this.blackTime = data.black_time;
                        this.lastUpdateTime = Date.now();
                        
                        this.activeTurn = data.fen.split(" ")[1] === "w" ? "white" : "black";
                        
                        const ml = document.getElementById('moveList');
                        const div = document.createElement('div');
                        div.className = "text-gray-500";
                        div.innerHTML = `${ml.children.length + 1}. <span class="text-white font-bold ml-1">${data.move}</span>`;
                        ml.appendChild(div);
                        ml.scrollTop = ml.scrollHeight;

                        // Check if game ended
                        if (data.outcome || !data.is_active) { 
                            this.isGameOver = true; 
                            this.statusMsg = "GAME OVER";
                            
                            let message = "Game Over";
                            if (data.outcome === 'timeout') {
                                message = data.winner ? `${data.winner} wins on time!` : "Time out!";
                            } else if (data.outcome === 'checkmate') {
                                message = data.winner ? `${data.winner} wins by checkmate!` : "Checkmate!";
                            } else if (data.outcome) {
                                message = `Draw by ${data.outcome}`;
                            }
                            alert(message);
                        }
                    } else if (data.type === 'game_over') {
                        this.isGameOver = true;
                        this.statusMsg = "GAME OVER";
                        alert("Winner: " + data.winner + " (" + data.outcome + ")");
                    } else if (data.type === 'chat') {
                        this.chatMessages.push({ player: data.player, text: data.message });
                        this.$nextTick(() => { this.$refs.chatLog.scrollTop = this.$refs.chatLog.scrollHeight; });
                    }
                },

                sendChat() {
                    if (!this.chatInput.trim()) return;
                    this.socket.send(JSON.stringify({ type: 'chat', message: this.chatInput }));
                    this.chatInput = '';
                },

                onDrop(source, target, piece) {
                    if (this.isGameOver || source === target) return 'snapback';
                    const isProm = (piece === 'wP' && target[1] === '8') || (piece === 'bP' && target[1] === '1');
                    if (isProm) { 
                        this.pendingMove = { source, target }; 
                        this.showPromotion = true; 
                        return 'snapback'; 
                    }
                    this.socket.send(JSON.stringify({ type: 'move', move: source + target }));
                },

                resign() {
                    if (confirm("Resign this game?")) {
                        this.socket.send(JSON.stringify({ type: 'resign' }));
                    }
                },

                selectPromotion(piece) {
                    this.socket.send(JSON.stringify({ 
                        type: 'move', 
                        move: this.pendingMove.source + this.pendingMove.target + piece 
                    }));
                    this.showPromotion = false;
                    this.pendingMove = null;
                },

                formatTime(sec) {
                    const m = Math.floor(sec / 60);
                    const s = Math.floor(sec % 60);
                    return `${m.toString().padStart(2, '0')}:${Math.max(0, s).toString().padStart(2, '0')}`;
                },

                getPieceImg(p) {
                    const pieces = {
                        'wK': '4/42/Chess_klt45.svg', 
                        'wQ': '1/15/Chess_qlt45.svg', 
                        'wR': '7/72/Chess_rlt45.svg', 
                        'wB': 'b/b1/Chess_blt45.svg', 
                        'wN': '7/70/Chess_nlt45.svg', 
                        'wP': '4/45/Chess_plt45.svg', 
                        'bK': 'f/f0/Chess_kdt45.svg', 
                        'bQ': '4/47/Chess_qdt45.svg', 
                        'bR': 'f/ff/Chess_rdt45.svg', 
                        'bB': '9/98/Chess_bdt45.svg', 
                        'bN': 'e/ef/Chess_ndt45.svg', 
                        'bP': 'c/c7/Chess_pdt45.svg'
                    };
                    return pieces[p];
                }
            }
        }
    </script>
</body>
</html>