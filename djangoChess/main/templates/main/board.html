<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Chess Match #{{ game.id }}</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <style>
        [x-cloak] { display: none !important; }
        .modal-overlay { z-index: 9999 !important; }
        .timer-active { @apply border-blue-500 shadow-[0_0_20px_rgba(59,130,246,0.4)] bg-blue-900/20; }
        #myBoard { @apply rounded-xl overflow-hidden border-4 border-gray-800 shadow-2xl; }
        .piece-417db { max-width: none !important; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen font-sans" x-data="chessGame()" x-init="initBoard()">

    <div class="container mx-auto py-8 px-4">
        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            <div class="lg:col-span-7 flex flex-col items-center">
                <div class="w-full max-w-[450px] mb-4 flex justify-between items-center bg-gray-800 p-4 rounded-xl border border-gray-700 transition-all"
                     :class="activeTurn === (isWhitePlayer ? 'black' : 'white') ? 'timer-active' : ''">
                    <p class="font-bold">Opponent: {% if game.white_player == request.user %}{{ game.black_player.username|default:"Waiting..." }}{% else %}{{ game.white_player.username }}{% endif %}</p>
                    <div class="text-3xl font-mono font-black" x-text="formatTime(isWhitePlayer ? blackTime : whiteTime)">00:00</div>
                </div>

                <div id="myBoard" class="mx-auto" style="width: 100%; max-width: 450px;"></div>

                <div class="w-full max-w-[450px] mt-4 flex justify-between items-center bg-gray-800 p-4 rounded-xl border border-gray-700 transition-all"
                     :class="activeTurn === (isWhitePlayer ? 'white' : 'black') ? 'timer-active' : ''">
                    <p class="font-bold">You ({{ request.user.username }})</p>
                    <div class="text-3xl font-mono font-black" x-text="formatTime(isWhitePlayer ? whiteTime : blackTime)">00:00</div>
                </div>

                <div class="mt-6 flex items-center gap-4 w-full max-w-[450px]">
                    <div class="flex-1 px-4 py-2 bg-gray-800 rounded-lg text-xs font-bold border border-gray-700" x-text="statusMsg">Connecting...</div>
                    <button @click="resign()" class="px-6 py-2 bg-red-600/10 border border-red-600/50 text-red-500 hover:bg-red-600 hover:text-white rounded-lg text-xs font-bold transition-all" :disabled="isGameOver">RESIGN</button>
                </div>
            </div>

            <div class="lg:col-span-5 space-y-6">
                <div class="bg-gray-800 rounded-2xl border border-gray-700 h-64 flex flex-col shadow-xl">
                    <div class="p-4 bg-gray-700/30 border-b border-gray-700 text-xs font-black uppercase text-gray-400">Move History</div>
                    <div class="p-4 overflow-y-auto grid grid-cols-2 gap-x-8 gap-y-1 font-mono text-sm" id="moveList">
                        {% for move in game.moves.all %}
                            <div class="text-gray-500">{{ forloop.counter }}. <span class="text-white font-bold ml-1">{{ move.move_san }}</span></div>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div x-show="showPromotion" class="modal-overlay fixed inset-0 bg-black/90 flex items-center justify-center" x-cloak>
        <div class="bg-gray-800 p-8 rounded-3xl text-center border border-gray-700 shadow-2xl">
            <h3 class="text-xl font-bold mb-6">Promote Pawn</h3>
            <div class="flex gap-4">
                <template x-for="p in [{c:'q', s:'♛'}, {c:'r', s:'♜'}, {c:'b', s:'♝'}, {c:'n', s:'♞'}]">
                    <button @click="selectPromotion(p.c)" class="w-16 h-16 bg-gray-700 hover:bg-blue-600 rounded-xl text-3xl">
                        <span x-text="p.s"></span>
                    </button>
                </template>
            </div>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <script>
        function chessGame() {
            return {
                whiteTime: parseFloat("{{ game.white_time }}"),
                blackTime: parseFloat("{{ game.black_time }}"),
                isWhitePlayer: "{{ request.user.username }}" === "{{ game.white_player.username }}",
                activeTurn: "{{ game.current_fen }}".split(" ")[1] === "w" ? "white" : "black",
                isGameOver: "{{ game.is_active }}" === "False",
                statusMsg: "Connecting...",
                showPromotion: false,
                pendingMove: null,
                socket: null,
                board: null,
                gameStarted: {% if game.last_move_timestamp %}true{% else %}false{% endif %},

                initBoard() {
                    this.socket = new WebSocket(`ws://${window.location.host}/ws/chess/{{ game.id }}/`);
                    this.board = Chessboard('myBoard', {
                        draggable: true,
                        position: "{{ game.current_fen }}",
                        orientation: this.isWhitePlayer ? 'white' : 'black',
                        onDrop: (s, t, p) => this.onDrop(s, t, p),
                        pieceTheme: (p) => `https://upload.wikimedia.org/wikipedia/commons/${this.getPieceImg(p)}`
                    });

                    this.socket.onmessage = (e) => this.handleSocketMessage(JSON.parse(e.data));
                    this.socket.onopen = () => this.statusMsg = "Live";
                    
                    setInterval(() => {
                        // CLOCK FIX: Only tick if game started and both players are here
                        if (!this.isGameOver && this.gameStarted) {
                            if (this.activeTurn === 'white' && this.whiteTime > 0) this.whiteTime -= 1;
                            else if (this.activeTurn === 'black' && this.blackTime > 0) this.blackTime -= 1;
                        }
                    }, 1000);
                },

                handleSocketMessage(data) {
                    if (data.error) { alert(data.error); this.board.position(this.board.fen()); return; }
                    
                    if (data.type === 'move') {
                        this.gameStarted = true; // First move made
                        this.board.position(data.fen);
                        this.whiteTime = data.white_time;
                        this.blackTime = data.black_time;
                        this.activeTurn = data.fen.split(" ")[1] === "w" ? "white" : "black";
                        
                        const ml = document.getElementById('moveList');
                        const div = document.createElement('div');
                        div.className = "text-gray-500";
                        // Using a simple move count based on current list
                        div.innerHTML = `${ml.children.length + 1}. <span class="text-white font-bold ml-1">${data.move}</span>`;
                        ml.appendChild(div);
                        ml.scrollTop = ml.scrollHeight;

                        if (data.outcome) { 
                            this.isGameOver = true; 
                            this.statusMsg = "GAME OVER"; 
                            alert("Game Over: " + data.outcome);
                        }
                    } else if (data.type === 'game_over') {
                        this.isGameOver = true;
                        this.statusMsg = "GAME OVER";
                        alert("Winner: " + data.winner + " (" + data.outcome + ")");
                    }
                },

                onDrop(source, target, piece) {
                    if (this.isGameOver || source === target) return 'snapback';
                    const isProm = (piece === 'wP' && target[1] === '8') || (piece === 'bP' && target[1] === '1');
                    if (isProm) { this.pendingMove = { source, target }; this.showPromotion = true; return 'snapback'; }
                    this.socket.send(JSON.stringify({ type: 'move', move: source + target }));
                },

                resign() {
                    if (confirm("Resign this game?")) {
                        this.socket.send(JSON.stringify({ type: 'resign' }));
                    }
                },

                selectPromotion(piece) {
                    this.socket.send(JSON.stringify({ type: 'move', move: this.pendingMove.source + this.pendingMove.target + piece }));
                    this.showPromotion = false;
                    this.pendingMove = null;
                },

                formatTime(sec) {
                    const m = Math.floor(sec / 60), s = Math.floor(sec % 60);
                    return `${m.toString().padStart(2, '0')}:${Math.max(0, s).toString().padStart(2, '0')}`;
                },

                getPieceImg(p) {
                    const pieces = {'wK': '4/42/Chess_klt45.svg', 'wQ': '1/15/Chess_qlt45.svg', 'wR': '7/72/Chess_rlt45.svg', 'wB': 'b/b1/Chess_blt45.svg', 'wN': '7/70/Chess_nlt45.svg', 'wP': '4/45/Chess_plt45.svg', 'bK': 'f/f0/Chess_kdt45.svg', 'bQ': '4/47/Chess_qdt45.svg', 'bR': 'f/ff/Chess_rdt45.svg', 'bB': '9/98/Chess_bdt45.svg', 'bN': 'e/ef/Chess_ndt45.svg', 'bP': 'c/c7/Chess_pdt45.svg'};
                    return pieces[p];
                }
            }
        }
    </script>
</body>
</html>